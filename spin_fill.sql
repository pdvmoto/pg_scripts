
/*

fill a table, see how far..

1. use id-generated
2. experiment with pk asc or hash
3. 

*/
-- drop table t1;

create table t_spin ( 
  id        bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
, amount    numeric
, dt        timestamp
, spoken    text 
, payload   text );

insert into t_spin ( amount, dt, spoken, payload )
select 
  ( random () * 100 * 1000 * 1000 )/100  /* two decimals) */
, CURRENT_TIMESTAMP as dt
, fnNumbertoWords ( ( random()*1000*1000)::bigint  )
, 'some payload'
from ( select generate_series ( 0, 1 ) as rownum ) as abc ;



/*
   now run for 1 min.  

*/ 

-- the pg, block version

DO $$
  DECLARE
   dt_starttime		timestamp ; 
   i_counter     	integer := 0 ;
   n_sec         	integer := 60  ; 
   n_per_sec 		real ; 
BEGIN

    -- in shell script, use $1
    -- n_sec := $1 ;

    RAISE NOTICE 'spin (pg, block): spinning for % seconds' , n_sec ; 

    dt_starttime := clock_timestamp()  ; 

    -- the actual loop
    WHILE ( to_char ( clock_timestamp() - dt_starttime , 'SSSS' )::integer < n_sec ) LOOP 

      insert into t_spin ( amount, dt, spoken, payload )
      select 
        ( random () * 100 * 1000 * 1000 )/100  /* two decimals) */
      , CURRENT_TIMESTAMP as dt
      , fnNumbertoWords ( ( random()*1000*1000)::bigint  )
      , 'some payload'
      from ( select generate_series ( 0, 9999 ) as rownum ) as abc ;

      commit ;
      i_counter := i_counter + 1 ; 

    END LOOP ;  

    n_per_sec := i_counter::real  / n_sec::real ;  -- need to do cast to get real nr.

    RAISE NOTICE 'spin (pg, block): seconds: % exec: %,  exec/sec :  % ' 
         , n_sec, i_counter , to_char ( n_per_sec, '999G999G999D999')  ; 

    -- when function: return
END
$$;


select count (*) from t_spin; 

-- 
